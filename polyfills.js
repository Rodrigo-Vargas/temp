(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["polyfills"],{

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/js/polyfills.js":
/*!*****************************!*\
  !*** ./src/js/polyfills.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */\r\n/* This file is meant as a standalone workflow for\r\n- testing support for link[rel=preload]\r\n- enabling async CSS loading in browsers that do not support rel=preload\r\n- applying rel preload css once loaded, whether supported or not.\r\n*/\r\n(function (w) {\r\n   \"use strict\";\r\n   // rel=preload support test\r\n   if (!w.loadCSS) {\r\n      w.loadCSS = function () {};\r\n   }\r\n   // define on the loadCSS obj\r\n   var rp = loadCSS.relpreload = {};\r\n   // rel=preload feature support test\r\n   // runs once and returns a function for compat purposes\r\n   rp.support = (function () {\r\n      var ret;\r\n      try {\r\n         ret = w.document.createElement(\"link\").relList.supports(\"preload\");\r\n      } catch (e) {\r\n         ret = false;\r\n      }\r\n      return function () {\r\n         return ret;\r\n      };\r\n   })();\r\n\r\n   // if preload isn't supported, get an asynchronous load by using a non-matching media attribute\r\n   // then change that media back to its intended value on load\r\n   rp.bindMediaToggle = function (link) {\r\n      // remember existing media attr for ultimate state, or default to 'all'\r\n      var finalMedia = link.media || \"all\";\r\n\r\n      function enableStylesheet() {\r\n         // unbind listeners\r\n         if (link.addEventListener) {\r\n            link.removeEventListener(\"load\", enableStylesheet);\r\n         } else if (link.attachEvent) {\r\n            link.detachEvent(\"onload\", enableStylesheet);\r\n         }\r\n         link.setAttribute(\"onload\", null);\r\n         link.media = finalMedia;\r\n      }\r\n\r\n      // bind load handlers to enable media\r\n      if (link.addEventListener) {\r\n         link.addEventListener(\"load\", enableStylesheet);\r\n      } else if (link.attachEvent) {\r\n         link.attachEvent(\"onload\", enableStylesheet);\r\n      }\r\n\r\n      // Set rel and non-applicable media type to start an async request\r\n      // note: timeout allows this to happen async to let rendering continue in IE\r\n      setTimeout(function () {\r\n         link.rel = \"stylesheet\";\r\n         link.media = \"only x\";\r\n      });\r\n      // also enable media after 3 seconds,\r\n      // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link\r\n      setTimeout(enableStylesheet, 3000);\r\n   };\r\n\r\n   // loop through link elements in DOM\r\n   rp.poly = function () {\r\n      // double check this to prevent external calls from running\r\n      if (rp.support()) {\r\n         return;\r\n      }\r\n      var links = w.document.getElementsByTagName(\"link\");\r\n      for (var i = 0; i < links.length; i++) {\r\n         var link = links[i];\r\n         // qualify links to those with rel=preload and as=style attrs\r\n         if (link.rel === \"preload\" && link.getAttribute(\"as\") === \"style\" && !link.getAttribute(\"data-loadcss\")) {\r\n            // prevent rerunning on link\r\n            link.setAttribute(\"data-loadcss\", true);\r\n            // bind listeners to toggle media back\r\n            rp.bindMediaToggle(link);\r\n         }\r\n      }\r\n   };\r\n\r\n   // if unsupported, run the polyfill\r\n   if (!rp.support()) {\r\n      // run once at least\r\n      rp.poly();\r\n\r\n      // rerun poly on an interval until onload\r\n      var run = w.setInterval(rp.poly, 500);\r\n      if (w.addEventListener) {\r\n         w.addEventListener(\"load\", function () {\r\n            rp.poly();\r\n            w.clearInterval(run);\r\n         });\r\n      } else if (w.attachEvent) {\r\n         w.attachEvent(\"onload\", function () {\r\n            rp.poly();\r\n            w.clearInterval(run);\r\n         });\r\n      }\r\n   }\r\n\r\n\r\n   // commonjs\r\n   if (true) {\r\n      exports.loadCSS = loadCSS;\r\n   } else {}\r\n}(typeof global !== \"undefined\" ? global : this));\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/js/polyfills.js?");

/***/ })

},[["./src/js/polyfills.js","runtime~polyfills"]]]);